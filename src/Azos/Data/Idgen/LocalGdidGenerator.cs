using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Azos.Apps;
using Azos.Collections;
using Azos.Conf;

namespace Azos.Data.Idgen
{
  /// <summary>
  /// Generates GDIDs based on local auto-incremented sequence variable pool within a date stamp aligned to seconds.
  /// This class does generate consecutive IDs while it runs, however it does not generate IDs without gaps because
  /// of the time stamp used in the high 32 bits of GDID, consequently this is not a full stateful GDID generator and
  /// it should be used for application which need to generate relatively limited number of IDs (hundreds of millions IDs) in
  /// comparison with full stateful GDID generator. The benefit of this class is its state-less design (no data written to disk)
  /// and simplicity.
  /// Attention: The generated IDs are only unique while generated by the same instance of this class, that is: if you allocate
  /// more than one instance of this class, then IDs generated by different instances will collide for the same sequence names.
  /// The era is set as an external parameter, so you should manually manage it.
  /// WARNING: The generator relies on proper App.TimeSource, otherwise duplicate IDs are theoretically possible
  /// due to clock drift/change although it is very unlikely as the caller would need to exhaust 2^28 combinations
  /// per sequence.
  /// </summary>
  /// <remarks>
  /// By design, this class can generate per authority up to 2^28 = ~268M ids per second, handling around 100 years since 2020, which equates to
  /// 2^60 combinations. Upon the exhaustion of 268M ids the timestamp gets assigned to the current one.

  /// Format:
  /// <code>
  ///  - ERA 32 bits - : AUTH 4bits : COUNTER 60 bits
  ///
  ///COUNTER := 32 bits SECONDS since Jan 1, 2020,     (2^32 = ~135 years until year 2155)
  ///           28 bits INT counter (auto-incremented)
  ///
  /// </code>
  /// </remarks>
  public sealed class LocalGdidGenerator : ApplicationComponent, IConfigurable, IGdidProvider
  {
    //Maximum number of counter per 1 second slice
    private const int MAX_INC = 268_435_000;// 2 ^ (60 - 32) = 268_435_456 - 456(rounding)
    public static readonly DateTime START = new DateTime(2020, 1, 1, 0, 0, 0, DateTimeKind.Utc);

    internal class scope : INamed
    {
      public string Name { get; set; }
      public Registry<sequence> Sequences = new Registry<sequence>();
    }

    internal class sequence : INamed, ISequenceInfo
    {
      internal scope Scope { get; set; }
      public string Name { get; set; }
      public volatile int Counter;


      public uint Era => 0;
      public ulong ApproximateCurrentValue => (ulong)Counter;
      public int TotalPreallocation => 0;
      public int RemainingPreallocation => 0;
      public string IssuerName => nameof(LocalGdidGenerator);
      public DateTime IssueUTCDate => DateTime.UtcNow;
    }

    public LocalGdidGenerator(IApplication application) : base(application) => ctor();
    public LocalGdidGenerator(IApplicationComponent director) : base(director) => ctor();

    private void ctor()
    {
      m_Name = Guid.NewGuid().ToString();
      initTimestamp();
    }

    private string m_Name;
    private int m_Authority;

    private Registry<scope> m_Scopes = new Registry<scope>();

    [Config]
    public uint Era{ get; set; }

    [Config]
    public int Authority
    {
      get => m_Authority;
      set
      {
        if (value<0 || value>0xf) throw new AzosException(StringConsts.ARGUMENT_ERROR+".Authority.set({0} is not [0..16])".Args(value));
        m_Authority = value;
      }
    }


    public override string ComponentLogTopic => CoreConsts.TOPIC_ID_GEN;


    public string TestingAuthorityNode { get => null; set {} }

    public IEnumerable<string> SequenceScopeNames => m_Scopes.Names;

    public string Name => m_Name;

    public void Configure(IConfigSectionNode node)
    {
      ConfigAttribute.Apply(this, node);
    }

    public GDID GenerateOneGdid(string scopeName, string sequenceName, int blockSize = 0, ulong? vicinity = 1152921504606846975, bool noLWM = false)
     => generate(scopeName.NonBlank(nameof(scopeName)), sequenceName.NonBlank(nameof(sequenceName)), 1).first;

    public ulong GenerateOneSequenceId(string scopeName, string sequenceName, int blockSize = 0, ulong? vicinity = ulong.MaxValue, bool noLWM = false)
    => generate(scopeName.NonBlank(nameof(scopeName)), sequenceName.NonBlank(nameof(sequenceName)), 1).first.Counter;

    public IEnumerable<ISequenceInfo> GetSequenceInfos(string scopeName)
    {
      var scope = m_Scopes[scopeName.NonBlank(nameof(scopeName))];
      if (scope==null) Enumerable.Empty<ISequenceInfo>();
      return scope.Sequences.Values;
    }

    public GDID[] TryGenerateManyConsecutiveGdids(string scopeName, string sequenceName, int gdidCount, ulong? vicinity = 1152921504606846975, bool noLWM = false)
    {
      var got = generate(scopeName.NonBlank(nameof(scopeName)), sequenceName.NonBlank(nameof(sequenceName)), gdidCount);
      var result = new GDID[got.count];
      var first = got.first;
      for(var i=0; i < got.count; i++)
       result[i] = new GDID(first.Era, first.Authority, first.Counter + (ulong)i);

      return result;
    }

    public ConsecutiveUniqueSequenceIds TryGenerateManyConsecutiveSequenceIds(string scopeName, string sequenceName, int idCount, ulong? vicinity = ulong.MaxValue, bool noLWM = false)
    {
      var got = generate(scopeName.NonBlank(nameof(scopeName)), sequenceName.NonBlank(nameof(sequenceName)), idCount);
      var result = new ConsecutiveUniqueSequenceIds(got.first.Counter, got.count);
      return result;
    }

    private ulong m_Timestamp;

    private bool initTimestamp()
    {
      var was = m_Timestamp;
      var nowdt = App.TimeSource.UTCNow;
      var span = nowdt - START;
      Aver.IsTrue(nowdt > START && span.TotalSeconds < uint.MaxValue, "App.Timesource is not set to current time `{0}` or it is now the year of 2150 or beyond".Args(START));
      var now = ((ulong)span.TotalSeconds) << (60 - 32);
      m_Timestamp = now;
      return  now > was;
    }

    private (GDID first, int count) generate(string scopeName,string seqName, int count)
    {
      if (count<1) count = count.KeepBetween(1, 1024);
      var scope = m_Scopes.GetOrRegister(scopeName, n => new scope{ Name = n } );
      var seq = scope.Sequences.GetOrRegister(seqName, n => new sequence{ Name = n });
      lock(seq)
      {
        var counter = seq.Counter;
        var increment = Math.Min(MAX_INC - counter, count);

        if (increment>0)
        {
          seq.Counter += increment;
        }
        else
        {
          const int MAX_WAIT_SPINS = 30;
          var spin = 0;
          while(!initTimestamp()) //spinlock - safeguard of block exhaustion within a second (not practically possible)
          {
            //safeguard in case of large clock drift due to clock change
            spin++;

            if (spin>MAX_WAIT_SPINS)
              throw new AzosException("Local GDID generation failed because wait limit was exceeded due to a significant clock drift");

            System.Threading.Thread.Sleep(105);
          }

          counter = Authority == 0 ? 1 : 0;
          seq.Counter = counter + increment;
        }

        var id = m_Timestamp | (0x0F_FF_FFFFUL & (ulong)counter);

        return (new GDID(Era, Authority, id), increment);
      }//lock
    }

  }
}
