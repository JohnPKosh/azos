/*<FILE_LICENSE>
 * Azos (A to Z Application Operating System) Framework
 * The A to Z Foundation (a.k.a. Azist) licenses this file to you under the MIT license.
 * See the LICENSE file in the project root for more information.
</FILE_LICENSE>*/

using System;
using System.Collections;
using System.IO;

using Azos.Serialization.JSON;

namespace Azos.Data
{
  /// <summary>
  /// Describes data change operation result: {ChangeType, AffectedCount, Message, Data}
  /// </summary>
  public struct ChangeResult : IJsonWritable, IJsonReadable
  {
    /// <summary>
    /// Change types: Undefined/Inserted/Updated/Upserted/Deleted/Other.
    /// Undefined is treated as non-success (OK: false)
    /// </summary>
    public enum ChangeType
    {
      /// <summary> Change type is undefined - the structure does not represent a valid change, OK: false </summary>
      Undefined = 0,

      /// <summary> A new item was inserted/added, e.g. a row into database </summary>
      Inserted,

      /// <summary> An existing item was updated/patched </summary>
      Updated,

      /// <summary> Either a new item was inserted or existing item was updated </summary>
      Upserted,

      /// <summary> An item was deleted </summary>
      Deleted,

      /// <summary>
      /// A complex change happened, a system may have inserted/updated/deleted items in different parts of the system.
      /// This value is different from others in that it does not specify how data has changed, it just indicates that
      /// request was processed, OK: true
      /// </summary>
      Processed
    }

    /// <summary>
    /// Describes data change operation result: Inserted/Deleted/etc.., rows affected, extra data etc.
    /// </summary>
    /// <param name="change">Change type: Inserted/Updated...</param>
    /// <param name="affectedCount">Affected entity count</param>
    /// <param name="msg">Optional message from the serving party</param>
    /// <param name="data">Returns optional extra data which is returned from the data change operation</param>
    public ChangeResult(ChangeType change, long affectedCount, string msg, object data)
    {
      Change = change;
      AffectedCount = affectedCount;
      Message = msg;
      Data = data;
    }

    /// <summary>
    /// Describes data change operation result: Inserted/Deleted/etc.., rows affected, extra data etc.
    /// Creates instance from JsonDataMap dictionary.
    /// </summary>
    /// <param name="map">Non-null map with keys: {change, affected, message, data}</param>
    public ChangeResult(JsonDataMap map)
    {
      map.NonNull(nameof(map));
      Change        = map["change"].AsEnum(ChangeType.Undefined);
      AffectedCount = map["affected"].AsLong();
      Message       = map["message"].AsString();
      Data          = map["data"];
    }

    /// <summary> True if change is not `Undefined` </summary>
    public bool IsOk => Change != ChangeType.Undefined;

    /// <summary> Specifies the change type Insert/Update/Delete etc.. </summary>
    public readonly ChangeType Change;

    /// <summary> How many entities/rows/docs was/were affected by the change </summary>
    public readonly long AffectedCount;

    /// <summary> Provides an optional message from the serving party </summary>
    public readonly string Message;

    /// <summary>
    /// Attaches optional extra data which is returned from the data change operation,
    /// for example a posted sale may return an OrderId object generated by the target store
    /// </summary>
    public readonly object Data;

    /// <summary>
    /// Writes this ChangeResult as a typical JSON object like: {OK: true, change: Inserted ... }
    /// </summary>
    void IJsonWritable.WriteAsJson(TextWriter wri, int nestingLevel, JsonWritingOptions options)
    {
      JsonWriter.WriteMap(wri, nestingLevel, options,
                    new DictionaryEntry("OK", IsOk),
                    new DictionaryEntry("change", Change),
                    new DictionaryEntry("affected", AffectedCount),
                    new DictionaryEntry("message", Message),
                    new DictionaryEntry("data", Data)
                   );
    }

    /// <summary>
    /// Reads ChangeResult back from JSON
    /// </summary>
    public (bool match, IJsonReadable self) ReadAsJson(object data, bool fromUI, JsonReader.DocReadOptions? options)
    {
      if (data is JsonDataMap map && map["OK"].AsBool())
        return (true, new ChangeResult(map));

      return (false, null);
    }
  }


  /// <summary>
  /// Struct returned from Form.Save(): it is either an error (IsSuccess==false), or TResult
  /// </summary>
  public struct SaveResult<TResult>
  {
    /// <summary>
    /// Creates error result
    /// </summary>
    public SaveResult(Exception error, Guid idempotencyToken = default(Guid))
    {
      Error = error;
      Result = default(TResult);
      IdempotencyToken = idempotencyToken;
    }

    /// <summary>
    /// Creates successful result
    /// </summary>
    public SaveResult(TResult result, Guid idempotencyToken = default(Guid))
    {
      Error = null;
      Result = result;
      IdempotencyToken = idempotencyToken;
    }

    /// <summary>
    /// Null on success or Error which prevented successful Save
    /// </summary>
    public readonly Exception Error;

    /// <summary>
    /// Returns the result of the form save, e.g. for filters this returns a resulting rowset.
    /// accessing this field does not throw exception if one is set.
    /// Use <see cref="GetResult"/> to return a valid result or throw
    /// </summary>
    public readonly TResult Result;

    /// <summary>
    /// Optional idempotency token issued by the server/processing entity. Guid.Empty is used when no token was issued.
    /// You can use the returned token to retry the seemingly failed server operation which may already have succeeded
    /// on the server in which case the token will ensure that the secondary re-executions are not going to affect server state
    /// beyond the very first change
    /// </summary>
    public readonly Guid IdempotencyToken;

    /// <summary>
    /// True if there is no error - a success
    /// </summary>
    public bool IsSuccess => Error == null;

    /// <summary>
    /// True if there is error - not success
    /// </summary>
    public bool IsError => !IsSuccess;

    /// <summary>
    /// Returns a SaveResult&lt;object&gt; representation
    /// </summary>
    public SaveResult<object> ToObject() => IsSuccess ? new SaveResult<object>(Result) : new SaveResult<object>(Error);

    /// <summary>
    /// If result is successful then returns it, otherwise throws an error
    /// </summary>
    public TResult GetResult() => IsSuccess ? Result : throw Error;
  }
}
